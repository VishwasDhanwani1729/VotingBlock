pragma solidity ^0.4.17;
/*
    Election will be conducted on specific time, after that no one will be allowed to vote.
    here owner has the power of allowing a candidate to participate in election which makes the sys
    centeralized (should be avoided). Same for voters registeration
*/
//Deployed at - 0x9d57Fd0F923CCEe9eFd7f4715C64f99a4b877E1A
contract Election{
    
    address public owner;
    string public electionName;
    
    struct Candidate{
        string partyName;
        string candidateName;
        address candidateAddress;
        uint voteCount;
        string ipfsHash;    //to store logo of candidate
    }
    struct Voter{
        bool authorized;    //add name field
        bool voted;
        uint votedTo;
    }
    
    Candidate[] public candidates;
    mapping(address=>Voter) public voters;
    
    uint public  totalVotes;
    uint public totalVoters;
    uint public totalCandidates;
    
    event candidateReceipt(string partyName,uint time);
    event receipt(address voterAddress,uint timeOfVote);
    event result(string partyName,address canidateAddress,address contractAddress);
    
    enum State {Campaigning,Voting,Result}
    /*  Campaigning - Candidates can register themselves
        Voting - voters will vote for a Candidate
        Result - the final result will be declared
    */
    State public state;
    
    Candidate public winnigParty;
    address public billContract;
    
    function Election(string name)public payable{
        owner = msg.sender;
        electionName = name;
        totalCandidates=0;
        totalVoters=0;
        totalVotes=0;
        state=State.Campaigning;
    }
    
    modifier ownerOnly(){
        require(msg.sender==owner);
        _;
    }
    
    modifier checkState(State _state){
        require(state == _state);
        _;
    }
    
    
    
    // either allow any one to be a candidate or hand the control to owner
    /*
        candidate should pay some minimal amount to take part in election 
        function addCandidate(string name) checkState(State.Campaigning) payable public {
            require(msg.value>=minimalAmount);
            candidates.push(Candidate(name,0);
        }
    */
    function getBalance()
    view public returns(uint){
        return this.balance;
    }
    
    function setDefault()checkState(State.Campaigning) ownerOnly public{
        address c1=0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2;
        address c2=0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db;
        candidates.push(Candidate('Party 1','Candidate 1',c1,0,'image'));
        candidates.push(Candidate('Party 2','Candidate 2',c2,0,'image'));
        totalCandidates=2;
        
        address v1=0xdD870fA1b7C4700F2BD7f44238821C26f7392148;
        address v2=0x583031D1113aD414F02576BD6afaBfb302140225;
        address v3=0x4B0897b0513fdC7C541B6d9D7E929C4e5364D2dB;
        voters[v1]=Voter(true,true,0);
        voters[v2]=Voter(true,true,0);
        voters[v3]=Voter(true,true,0);
        totalVoters=3;
        totalVotes=3;
        
    }
    
    function addCandidate(string partyName,string candidateName,address add,string imageHash) checkState(State.Campaigning)  ownerOnly public{
        candidates.push(Candidate(partyName,candidateName,add,0,imageHash));
        totalCandidates++;
        candidateReceipt(partyName,now);
    }
    
    function changeState(uint index) ownerOnly public{  //will change the state from Campaigning to voting and voting to result
        require(index>=0 && index<3);
        state = State(index);
    }
    
    function addVoter(address person) checkState(State.Campaigning) ownerOnly public{
        voters[person]=Voter(true,false,0);
        totalVoters++;
    }
    
    function voting(uint index) checkState(State.Voting) public{
        require(index>=0 && index<totalCandidates); //verifiying index
        
        require(!voters[msg.sender].voted);         //will check if user has already voted or not, if yes then don't allow him to vote
        require(voters[msg.sender].authorized);     //will check if user is authorized or not , if not then don't allow him to vote
        
        voters[msg.sender].voted=true;
        voters[msg.sender].votedTo = index;
        candidates[index].voteCount++;              //upgrading vote count
        totalVotes++;
        receipt(msg.sender,now);
    }
    
    function results() checkState(State.Result) ownerOnly public{
        uint max=0;
        for(uint i=0;i<totalCandidates;i++){
            if(candidates[max].voteCount < candidates[i].voteCount){
                max=i;
            }
        }
        winnigParty = candidates[max];
        Bill newBill = (new Bill).value(this.balance)(winnigParty.candidateAddress);
        billContract=address(newBill);
        
        //calling event
        result(winnigParty.partyName,winnigParty.candidateAddress,billContract);
    }
    function destroy() ownerOnly public{
        selfdestruct(msg.sender);
    }
}
//get proposalscount
contract Bill{
    address public owner;
    struct Bills{
        string name;
        string proposal;
        uint upvotes;
        uint totalvotes;
        bool finalized;
    }
    
    Bills[] public bills;
    uint public billsCount;
    event billCreationReceipt(string billName,uint timestamp);
    modifier ownerOnly(){
        require(msg.sender==owner);
        _;
    }
    modifier billIndex(uint index){
        require(index<bills.length);
        _;
    }
    modifier isNotFinalized(uint index){
        require(!bills[index].finalized);   //only those bills which are not finalized yet
        _;
    }
    function Bill(address winnigPartyAddress)
    payable
    public{
        owner=winnigPartyAddress;
        billsCount=0;
    }
    
    function getBalance()
    public view returns(uint){
        return this.balance;
    }
    
    function proposal(string name,string description) ownerOnly
    public{
        bills.push(Bills(name,description,0,0,false));
        billsCount++;
        billCreationReceipt(name,now);  //calling event
    }
    
    function voteBill(uint index,uint vote) billIndex(index) isNotFinalized(index)
    public{
        if(vote==0)
            bills[index].upvotes++;
        bills[index].totalvotes++;
    }
    
    function finalizeBill(uint index) billIndex(index) ownerOnly isNotFinalized(index)
    public{
        Bills storage bill = bills[index];
        require(bill.upvotes*2>=bill.totalvotes);
        bill.finalized=true;
    }
    
    
    
    
    //*********************************************************************************************************
    /*
    Voting block would deploy this contract with some money and winning party would be owner
    and for transactions they have to use this contract(indirect control over tokens)
    
    function Bill(address winnigPartyAddress)public payable{
        owner = winnigPartyAddress;    
    }
    */
    //Transactions done by party
    struct Transactions{
        address to;
        string description;
        uint valueInEther;
    }
    Transactions[] public transactions;
    function sendTokens(address to,string description,uint value)ownerOnly  //value should be passed in wei
    public{
        require(value<=this.balance);
        transactions.push(Transactions(to,description,value));
        to.transfer(value);
    }
}